/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package it.unibo.artificial_vision_tracking;

import org.bytedeco.javacpp.Loader;
import org.bytedeco.javacv.FrameGrabber;
import org.bytedeco.opencv.opencv_java;

import it.unibo.artificial_vision_tracking.aruco_markers.CameraCalibrator;
import it.unibo.artificial_vision_tracking.aruco_markers.CameraPose;
import it.unibo.artificial_vision_tracking.graphics.InputParameters;

import org.opencv.objdetect.Objdetect;
import org.opencv.core.Mat;

import java.util.List;

/**
 * Main class of the project.
 */
public final class App {
    /**
     * Loading the OpenCV native library
     */
    static {
        Loader.load(opencv_java.class);
    }

    private App() {
        throw new UnsupportedOperationException("Utility class");
    }
    /**
     * Main method.
     * @param args
     * @throws FrameGrabber.Exception
     * @throws InterruptedException
     */
    public static void main(final String[] args) throws FrameGrabber.Exception, InterruptedException {
        // Let the user set the application parameters
        final InputParameters ip = new InputParameters();
        ip.createWindow();

        // Wait for the user to set the parameters
        final int squaresX = ip.getSquaresX();
        final int squaresY = ip.getSquaresY();
        final float markerLength = ip.getMarkerLength();
        final String directoryPath = ip.getDirectoryPath();
        final int selectedCamera = ip.getCameraIndex();
        final int dictionaryType = convertDictionary(ip.getDictionaryType());
        // Close the input parameters window
        ip.close();


        //Default values for calibration
        /*final int squaresX = 11; // number of squares on the X axis of the calibration chessboard
        final int squaresY = 8; // number of squares on the Y axis of the calibration chessboard
        final float markerLength = 0.07f; // marker side length (in meters)
        final String directoryPath = "..\\calibration_images\\"; // path to the directory containing the camera calibration images
        final int dictionaryType = Objdetect.DICT_4X4_100; // type of dictionary employed for the markers
        final int selectedCamera = 1;   // camera index to be used for the calibration (starting from 0)
        */
        //Default values to generate the markers sheet
        /*final int markerSheetMarkersX = 8; // number of markers on the X axis
        final int markerSheetMarkersY = 10; // number of markers on the Y axis
        final int markerSheetMarkerLength = 50; // Marker side length (in pixel)
        final int markerSheetMarkerSeparation = 10; // Separation between markers (in pixel)
        final String fileName = "markersSheet"; // Name of the file containing the markers sheet
        GenerateMarkersSheet gms = new GenerateMarkersSheet(markerSheetMarkersX, markerSheetMarkersY, 
            markerSheetMarkerLength, markerSheetMarkerSeparation, dictionaryType, fileName);
        gms.generateMarkersSheet();
        */


        //Camera calibration
        final CameraCalibrator cc = new CameraCalibrator(squaresX, squaresY, directoryPath);
        final List<Mat> cameraParam = cc.calibration();


        //Camera pose estimation
        final CameraPose cp = new CameraPose(cameraParam.get(0), cameraParam.get(1), 
            markerLength, dictionaryType, selectedCamera);
        cp.calcPose();


        //Test of RobotScreenSaver
        /*RobotScreenSaver rss = new RobotScreenSaver("ws://10.0.0.5:81", List.of(2,3,4,5));
        rss.screenSaver(cameraParam.get(0), cameraParam.get(1), markerLength, dictionaryType, selectedCamera);
        */
    }

    /**
     * Convert the dictionary type from string to integer.
     * @param dictionaryType
     * @return the integer value of the dictionary type
     */
    private static int convertDictionary(final String dictionaryType) {
        switch (dictionaryType) {
            case "DICT_4X4_100":
                return Objdetect.DICT_4X4_100;
            case "DICT_4X4_1000":
                return Objdetect.DICT_4X4_1000;
            case "DICT_5X5_100":
                return Objdetect.DICT_5X5_100;
            case "DICT_5X5_1000":
                return Objdetect.DICT_5X5_1000;
            case "DICT_6X6_100":
                return Objdetect.DICT_6X6_100;
            case "DICT_6X6_1000":
                return Objdetect.DICT_6X6_1000;
            default:
                return Objdetect.DICT_4X4_100;
        }
    }
}
